We'll explore two of the most fundamental algorithm categories: **searching** and **sorting**. 
To build a well-rounded mastery of algorithms (especially useful for problem-solving, competitive programming, and systems design), here are the **other major categories** also worth expanding into:

---

## ğŸ”¢ 1. **Divide and Conquer Algorithms**

* Break the problem into smaller subproblems, solve them independently, and combine.
* **Examples:**

  * Merge Sort, Quick Sort
  * Binary Search
  * Karatsuba Multiplication
  * Closest Pair of Points
  * Strassenâ€™s Matrix Multiplication

---

## ğŸ“ 2. **Greedy Algorithms**

* Make the locally optimal choice at each step.
* **Examples:**

  * Dijkstraâ€™s Algorithm (can also be considered greedy + graph)
  * Huffman Encoding
  * Kruskalâ€™s & Primâ€™s MST algorithms
  * Activity Selection
  * Fractional Knapsack

---

## ğŸ§® 3. **Dynamic Programming (DP)**

* Break down problems into overlapping subproblems and store solutions (memoization or tabulation).
* **Examples:**

  * Fibonacci, LIS, LCS
  * Matrix Chain Multiplication
  * 0/1 Knapsack
  * Edit Distance
  * DP on Trees, DP on Graphs
* Advanced: Bitmask DP, Digit DP, DP with Segment Tree, DP with Convex Hull Trick

---

## ğŸŒ³ 4. **Graph Algorithms**

* Fundamental in networks, maps, dependencies.
* **Examples:**

  * BFS, DFS
  * Dijkstraâ€™s, Bellman-Ford, Floyd-Warshall
  * Kruskalâ€™s & Primâ€™s MST
  * Topological Sorting
  * Tarjanâ€™s SCC
  * Kosarajuâ€™s Algorithm
  * Euler Tour, Bridges, Articulation Points

---

## ğŸ’¡ 5. **Backtracking and Branch & Bound**

* Try all possibilities, backtrack when constraints fail.
* **Examples:**

  * N-Queens
  * Sudoku Solver
  * Subset Sum, Permutations/Combinations
  * Travelling Salesman Problem (TSP)
  * Branch & Bound for Optimization Problems

---

## ğŸ”’ 6. **Bit Manipulation**

* Efficient low-level optimization using bits.
* **Examples:**

  * Checking powers of 2
  * Counting set bits
  * XOR tricks (e.g. finding unique number)
  * Bitmask DP

---

## ğŸ“Š 7. **Mathematical Algorithms**

* Number theory and combinatorics-heavy problems.
* **Examples:**

  * GCD, LCM
  * Sieve of Eratosthenes
  * Modular Arithmetic (modular inverse, exponentiation)
  * Prime Factorization
  * Matrix Exponentiation
  * Eulerâ€™s Totient Function
  * Fast Fourier Transform (FFT)

---

## ğŸŒŒ 8. **Geometry Algorithms**

* Work with coordinates, shapes, and spatial relations.
* **Examples:**

  * Convex Hull (Grahamâ€™s scan, Andrewâ€™s Monotone Chain)
  * Line Sweep Algorithms
  * Closest Pair of Points
  * Segment Intersection
  * Rotating Calipers
  * Point in Polygon

---

## ğŸ”„ 9. **String Algorithms**

* Specialized for string and text processing.
* **Examples:**

  * KMP, Rabin-Karp, Z-Algorithm
  * Aho-Corasick
  * Suffix Array / Suffix Tree
  * Longest Palindromic Substring
  * Trie / Patricia Tree
  * Rolling Hash, Manacherâ€™s Algorithm

---

## ğŸ› 10. **Data Structure Based Algorithms**

* Algorithms powered by specialized structures.
* **Examples:**

  * Segment Trees / Binary Indexed Trees (Fenwick)
  * Union-Find (Disjoint Set)
  * Balanced BST (AVL, Red-Black)
  * Tries, Heaps, Priority Queues
  * LRU Cache (LinkedHashMap or OrderedDict)
  * Hashmaps, Bloom Filters

---

## ğŸ“ˆ 11. **Advanced Topics (Competitive/Real World)**

* Heavy tools used in hard problems or real-world systems.
* **Examples:**

  * Moâ€™s Algorithm (offline query processing)
  * Centroid Decomposition (on trees)
  * Heavy-Light Decomposition
  * Persistent Data Structures
  * Convex Hull Trick, Li Chao Tree
  * Suffix Automaton
  * Network Flow (Ford-Fulkerson, Dinicâ€™s Algorithm)

---

## ğŸ¯ Suggested Path (Post-Sorting/Search):

1. **Dynamic Programming**
2. **Graph Algorithms**
3. **Greedy + Backtracking**
4. **String Algorithms**
5. **Math + Number Theory**
6. **Data Structures (custom + advanced)**
7. **Geometry / Bit Manipulation / Others**

---
