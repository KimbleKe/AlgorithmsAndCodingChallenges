We'll explore two of the most fundamental algorithm categories: **searching** and **sorting**. 
To build a well-rounded mastery of algorithms (especially useful for problem-solving, competitive programming, and systems design), here are the **other major categories** also worth expanding into:

---

## 🔢 1. **Divide and Conquer Algorithms**

* Break the problem into smaller subproblems, solve them independently, and combine.
* **Examples:**

  * Merge Sort, Quick Sort
  * Binary Search
  * Karatsuba Multiplication
  * Closest Pair of Points
  * Strassen’s Matrix Multiplication

---

## 📐 2. **Greedy Algorithms**

* Make the locally optimal choice at each step.
* **Examples:**

  * Dijkstra’s Algorithm (can also be considered greedy + graph)
  * Huffman Encoding
  * Kruskal’s & Prim’s MST algorithms
  * Activity Selection
  * Fractional Knapsack

---

## 🧮 3. **Dynamic Programming (DP)**

* Break down problems into overlapping subproblems and store solutions (memoization or tabulation).
* **Examples:**

  * Fibonacci, LIS, LCS
  * Matrix Chain Multiplication
  * 0/1 Knapsack
  * Edit Distance
  * DP on Trees, DP on Graphs
* Advanced: Bitmask DP, Digit DP, DP with Segment Tree, DP with Convex Hull Trick

---

## 🌳 4. **Graph Algorithms**

* Fundamental in networks, maps, dependencies.
* **Examples:**

  * BFS, DFS
  * Dijkstra’s, Bellman-Ford, Floyd-Warshall
  * Kruskal’s & Prim’s MST
  * Topological Sorting
  * Tarjan’s SCC
  * Kosaraju’s Algorithm
  * Euler Tour, Bridges, Articulation Points

---

## 💡 5. **Backtracking and Branch & Bound**

* Try all possibilities, backtrack when constraints fail.
* **Examples:**

  * N-Queens
  * Sudoku Solver
  * Subset Sum, Permutations/Combinations
  * Travelling Salesman Problem (TSP)
  * Branch & Bound for Optimization Problems

---

## 🔒 6. **Bit Manipulation**

* Efficient low-level optimization using bits.
* **Examples:**

  * Checking powers of 2
  * Counting set bits
  * XOR tricks (e.g. finding unique number)
  * Bitmask DP

---

## 📊 7. **Mathematical Algorithms**

* Number theory and combinatorics-heavy problems.
* **Examples:**

  * GCD, LCM
  * Sieve of Eratosthenes
  * Modular Arithmetic (modular inverse, exponentiation)
  * Prime Factorization
  * Matrix Exponentiation
  * Euler’s Totient Function
  * Fast Fourier Transform (FFT)

---

## 🌌 8. **Geometry Algorithms**

* Work with coordinates, shapes, and spatial relations.
* **Examples:**

  * Convex Hull (Graham’s scan, Andrew’s Monotone Chain)
  * Line Sweep Algorithms
  * Closest Pair of Points
  * Segment Intersection
  * Rotating Calipers
  * Point in Polygon

---

## 🔄 9. **String Algorithms**

* Specialized for string and text processing.
* **Examples:**

  * KMP, Rabin-Karp, Z-Algorithm
  * Aho-Corasick
  * Suffix Array / Suffix Tree
  * Longest Palindromic Substring
  * Trie / Patricia Tree
  * Rolling Hash, Manacher’s Algorithm

---

## 🏛 10. **Data Structure Based Algorithms**

* Algorithms powered by specialized structures.
* **Examples:**

  * Segment Trees / Binary Indexed Trees (Fenwick)
  * Union-Find (Disjoint Set)
  * Balanced BST (AVL, Red-Black)
  * Tries, Heaps, Priority Queues
  * LRU Cache (LinkedHashMap or OrderedDict)
  * Hashmaps, Bloom Filters

---

## 📈 11. **Advanced Topics (Competitive/Real World)**

* Heavy tools used in hard problems or real-world systems.
* **Examples:**

  * Mo’s Algorithm (offline query processing)
  * Centroid Decomposition (on trees)
  * Heavy-Light Decomposition
  * Persistent Data Structures
  * Convex Hull Trick, Li Chao Tree
  * Suffix Automaton
  * Network Flow (Ford-Fulkerson, Dinic’s Algorithm)

---

## 🎯 Suggested Path (Post-Sorting/Search):

1. **Dynamic Programming**
2. **Graph Algorithms**
3. **Greedy + Backtracking**
4. **String Algorithms**
5. **Math + Number Theory**
6. **Data Structures (custom + advanced)**
7. **Geometry / Bit Manipulation / Others**

---
